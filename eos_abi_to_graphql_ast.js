'use strict'

const {
  GraphQLList,
  GraphQLNonNull,
  GraphQLObjectType,
  GraphQLInputObjectType
} = require('graphql')
const eosio_types = require('./eosio_types/index.js')
const authorization_type = require('./graphql_input_types/authorization.js')
const query_argument_fields = require('./graphql_input_types/query_argument_fields.js')
const resolve = require('./query_resolver.js')

/**
 * Recursively resolves all the base fields and collects them into a single array.
 * @param {string} base Base struct field name.
 * @param {Array<object>} structs List of ABI structs.
 * @returns {Array} List of base fields.
 * @ignore
 */
function handleBaseFields(base, structs) {
  const base_struct = structs.find(({ name }) => name == base)
  const { fields, base: nested_base } = base_struct
  return [
    ...(nested_base ? handleBaseFields(nested_base, structs) : []),
    ...fields
  ]
}

/**
 * Performs some transformations on the ABI structs to make it malleable to the GraphQL spec.
 * ABI structs are converted onto GraphQL Types.
 * @param {object} structs ABI structs
 * @returns {Obejct} Struct AST that will be consumed by `eosio_abi_to_graphql_ast`.
 * @ignore
 */
function handleStructs(structs) {
  let graphql_ast_structs = {}

  for (const struct of structs) {
    const { name, base, fields } = struct
    const fields_with_base_fields = base
      ? [...handleBaseFields(base, structs), ...fields]
      : fields
    let i = 0
    let ast_fields = new Array(fields_with_base_fields.length)
    for (const field of fields_with_base_fields) {
      const optional = !!field.type.match(/[$?]/gmu)
      const binary_ex = !!field.type.match(/\$/gmu)
      const variant = !!field.type.match(/@/gmu)
      const list = !!field.type.match(/\[\]/gmu)
      let type = field.type.replace(/[[\]?$@]/gmu, '')
      const object = !eosio_types[type]
      ast_fields[i] = {
        name: field.name,
        type,
        $info: { object, optional, list, binary_ex, variant }
      }
      i++
    }
    graphql_ast_structs[name] = ast_fields
  }
  return graphql_ast_structs
}

/**
 * Generate an Abstract syntax tree (AST) for an EOSIO application Binary interface (ABI).
 * @param {object} abi EOSIO smart contract Application Binary interface (ABI).
 * @returns {object} a GraphQL AST for a given smart contract.
 */
function eosio_abi_to_graphql_ast(abi) {
  const { types, variants } = abi

  const structs = [
    ...variants.map(({ name, types }) => ({
      name,
      base: '',
      fields: types.map(item => ({ name: item, type: item + '$@' })) // @ indiacted a variant type and binary extention.
    })),
    ...types.map(({ new_type_name, type }) => ({
      name: new_type_name,
      base: '',
      fields: [{ name: new_type_name, type }]
    })),
    ...abi.structs
  ]

  const structs_ast = handleStructs(structs)

  return Object.freeze(structs_ast)
}

/**
 * Wraps a GraphQL type in a GraphQLNonNullType and GraphQLListType.
 * @param {object} type GraphQL type to wrap.
 * @param {object} Arg Argument
 * @param {Bool} Arg.optional Wraps GraphQL type optional type.
 * @param {Bool} Arg.list Wraps GraphQL type in list type.
 * @returns {object} wrapped GraphQL type.
 */
function Wrap(type, { optional, list }) {
  let gql_type = type
  if (list) gql_type = new GraphQLList(gql_type)
  if (!optional) gql_type = new GraphQLNonNull(gql_type)
  return gql_type
}

/**
 * Generates GraphQL query and mutation fields from an ABI AST.
 * @param {object} AST Abstract syntax tree generated by `eosio_abi_to_graphql_ast` function.
 * @param {object} ABI EOSIO application binary interface (ABI).
 * @param {string} [account_name] EOSIO account name.
 * @returns {object} GraphQL query and mutation fields.
 */
function get_graphql_fields_from_AST(AST, ABI, account_name = '') {
  const { tables, actions } = ABI
  const gql_account_name = account_name.replace(/\./gmu, '_') + '_'

  let query_fields = {}
  const queryTypes = {}
  const GQL_TYPES = {}

  for (const table of tables) {
    let { name: table_name, type: table_type } = table
    table_name = table_name.replace(/\./gmu, '_')
    const table_fields = AST[table_type]

    const buildQGL = (fields, acc = {}) => {
      for (const field of fields) {
        const { name, type, $info } = field

        // Do this because of variant type from table.
        const resolve = (data, args, context, { fieldName }) => {
          if ($info.variant) return type == data[0] ? data[1] : null
          return data[fieldName]
        }

        if ($info.object) {
          if (!GQL_TYPES[type])
            GQL_TYPES[type] = new GraphQLObjectType({
              name: gql_account_name + type,
              fields: buildQGL(AST[type])
            })

          acc = {
            ...acc,
            [name]: { type: Wrap(GQL_TYPES[type], $info), resolve }
          }
        } else
          acc = {
            ...acc,
            [name]: { type: Wrap(eosio_types[type], $info), resolve }
          }
      }
      return acc
    }

    if (!queryTypes[table_type])
      queryTypes[table_type] = {
        type: new GraphQLList(
          new GraphQLObjectType({
            name: gql_account_name + table_type + '_query',
            fields: buildQGL(table_fields)
          })
        ),
        args: {
          arg: {
            name: 'argument_type',
            type: query_argument_fields
          }
        },
        resolve
      }

    query_fields[table_name] = queryTypes[table_type]
  }

  const GQL_MTYPES = {}
  let mutation_fields = {}
  const mutationTypes = {}
  for (const action of actions) {
    let { name: action_name, type: action_type } = action
    action_name = action_name.replace(/\./gmu, '_')
    const action_fields = AST[action_type]

    const buildQGL = (fields, acc = {}) => {
      for (const field of fields) {
        const { name, type, $info } = field
        if ($info.object) {
          if (!GQL_MTYPES[type])
            GQL_MTYPES[type] = new GraphQLInputObjectType({
              name: gql_account_name + 'input_' + type,
              fields: buildQGL(AST[type])
            })
          acc = { ...acc, [name]: { type: Wrap(GQL_MTYPES[type], $info) } }
        } else
          acc = { ...acc, [name]: { type: Wrap(eosio_types[type], $info) } }
      }
      return acc
    }

    if (!mutationTypes[action_type])
      mutationTypes[action_type] = {
        type: new GraphQLInputObjectType({
          name: gql_account_name + action_type,
          fields: {
            ...buildQGL(action_fields),
            authorization: {
              type: new GraphQLList(new GraphQLNonNull(authorization_type))
            }
          }
        })
      }

    mutation_fields[action_name] = mutationTypes[action_type]
  }

  return { query_fields, mutation_fields }
}

module.exports = { get_graphql_fields_from_AST, eosio_abi_to_graphql_ast }

'use strict'

const {
  GraphQLList,
  GraphQLInputObjectType,
  GraphQLNonNull,
  GraphQLError
} = require('graphql')
const authorization_type = require('../../../public/eos_types/authorization_type.js')
const {
  transaction_receipt_type,
  packed_transaction_type
} = require('../../../public/eos_types/mutation_types')
const get_block = require('../../network/get_block.js')
const get_info = require('../../network/get_info.js')
const get_required_keys = require('../../network/get_required_keys')
const push_transaction = require('../../network/push_transaction.js')
const serialize_actions = require('../../serialize/actions.js')
const serialize_extensions = require('../../serialize/extension.js')
const serialize_header = require('../../serialize/transaction_header.js')
const abi_to_ast = require('../abi_to_ast/index.js')
const { configuration, defaultValue } = require('./configuration')
const serialize_transaction_data = require('./serialize_transaction_data.js')

/**
 * This function builds mutation fields of a GraphQL query of the Schema from an ABI of a given EOS smart contract.
 * @name build_mutation_fields
 * @kind function
 * @param {object} ABI ABI for a smart contract.
 * @param {string} contract Name of the smart contract account.
 * @param {bool} broadcast Push the transaction to blockchain, else return serialized transaction.
 * @returns {object} GraphQL mutation fields.
 * @ignore
 */
function build_mutation_fields(ABI, contract, broadcast) {
  const { ast_input_object_types, abi_ast } = abi_to_ast(ABI)

  /*
   * Generate GraphQL mutation fields for a given ABI utilises the AST generated by abi_ast.
   */
  const fields = ABI.actions.reduce(
    (acc, { name, type, ricardian_contract }) => ({
      ...acc,
      [name]: {
        description: (() => {
          let description = ricardian_contract.match(/^title: .+$/gmu)
          if (description) return description[0].replace('title: ', '')
          return ''
        })(),
        type: new GraphQLInputObjectType({
          name: `${name}_data`,
          fields: () => ({
            ...(() => {
              if (Object.keys(ast_input_object_types[type]._fields()).length)
                return ast_input_object_types[type]._fields()
            })(),
            authorization: {
              description: 'Authorization array object.',
              type: new GraphQLNonNull(new GraphQLList(authorization_type))
            }
          })
        })
      }
    }),
    {}
  )

  /*
   * We create this prefix to to give an graphql fields unique names specific to the smart contract.
   * this prevents any GraphQL Duplicate errors being thrown.
   * Moreover and EOSIO account names with periods need to be transformed into _ as periods are invalid graphql chars.
   */
  const contract_name_prefix = contract.replace(/[.]+/gmu, '_')

  return {
    [`${contract_name_prefix}_transaction`]: {
      type: broadcast ? transaction_receipt_type : packed_transaction_type,
      description: `Update the \`${contract}\` smart contract.`,
      args: {
        actions: {
          type: GraphQLNonNull(
            new GraphQLList(
              GraphQLNonNull(
                new GraphQLInputObjectType({
                  name: `${contract_name_prefix}_action_type`,
                  description: `Here is a list of available ${contract} smart contract mutations.`,
                  fields
                })
              )
            )
          )
        },
        configuration: {
          description:
            'An optional configuration object that controls various elements of a transaction.',
          type: configuration
        }
      },
      async resolve(
        _,
        { configuration = defaultValue, actions },
        { rpc_url, private_keys = [] }
      ) {
        const context_free_actions = []
        const transaction_extensions = []

        let action_array = []
        // create a list of transaction actions
        for await (const action of actions)
          action_array.push(
            ...(await Promise.all(
              Object.keys(action).map(async actionType => {
                const { authorization, ...data } = action[actionType]
                return {
                  account: contract,
                  action: actionType,
                  authorization,
                  data: await serialize_transaction_data({
                    actionType,
                    data,
                    abi_ast
                  })
                }
              })
            ))
          )

        // EOS transaction body
        const transaction_body =
          serialize_actions(context_free_actions) +
          serialize_actions(action_array) +
          serialize_extensions(transaction_extensions) +
          '0000000000000000000000000000000000000000000000000000000000000000'

        const { chain_id, head_block_num } = await get_info({ rpc_url })
        const block_num_or_id = head_block_num - configuration.blocksBehind
        const { timestamp, block_num, ref_block_prefix } = await get_block({
          rpc_url,
          block_num_or_id
        })

        // TaPoS expiry time.
        const expiration =
          Math.round(Date.parse(timestamp + 'Z') / 1000) +
          configuration.expireSeconds

        // Generates a transaction header for a EOS transaction.
        const transaction_header = serialize_header({
          expiration,
          ref_block_num: block_num & 0xffff,
          ref_block_prefix,
          max_net_usage_words: configuration.max_net_usage_words,
          max_cpu_usage_ms: configuration.max_cpu_usage_ms,
          delay_sec: configuration.delay_sec
        })

        if (!broadcast)
          return {
            chain_id,
            transaction_header,
            transaction_body
          }

        let key_chain = []

        if (broadcast && private_keys.length) {
          const { public_key_from_private } = require('eos-ecc')

          // Remove any duplicate keys.
          private_keys = [...new Set(private_keys)]

          // Validate wif private keys and calc the corresponding public key(s).
          key_chain = await Promise.all(
            [...private_keys].map(async pk => ({
              public_key: await public_key_from_private(pk),
              private_key: pk
            }))
          )
        }

        const { sign_txn } = require('eos-ecc')

        const { required_keys, error } = await get_required_keys({
          rpc_url,
          transaction: {
            expiration: new Date(expiration).toISOString().split('.')[0],
            ref_block_num: block_num & 0xffff,
            ref_block_prefix,
            max_net_usage_words: configuration.max_net_usage_words,
            max_cpu_usage_ms: configuration.max_cpu_usage_ms,
            delay_sec: configuration.delay_sec,
            context_free_actions,
            transaction_extensions,
            actions: action_array.map(({ action, ...data }) => ({
              name: action,
              ...data
            }))
          },
          available_keys: key_chain.map(({ public_key }) => public_key)
        })

        if (error) throw new GraphQLError(error)

        // Generate sigs
        const signatures = await Promise.all(
          required_keys.map(key => {
            return sign_txn({
              hex: chain_id + transaction_header + transaction_body,
              wif_private_key: key_chain.find(
                ({ public_key }) => key == public_key
              ).private_key
            })
          })
        )

        const receipt = await push_transaction({
          transaction: transaction_header + transaction_body,
          signatures,
          rpc_url
        })

        if (receipt.error) throw new GraphQLError(receipt.error)

        return receipt
      }
    }
  }
}

module.exports = build_mutation_fields
